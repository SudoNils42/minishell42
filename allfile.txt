/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 15:55:53 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:18 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	exec_builtins(t_data *data)
{
	if (ft_strcmp(data->command->args[0], "pwd") == 0)
		data->exit_status = ft_pwd();
	else if (ft_strcmp(data->command->args[0], "env") == 0)
		data->exit_status = ft_env(data);
	else if (ft_strcmp(data->command->args[0], "echo") == 0)
		data->exit_status = ft_echo(data);
	else if (ft_strcmp(data->command->args[0], "cd") == 0)
		data->exit_status = ft_cd(data);
	else if (ft_strcmp(data->command->args[0], "export") == 0)
		data->exit_status = ft_export(data);
	else if (ft_strcmp(data->command->args[0], "unset") == 0)
		data->exit_status = ft_unset(data);
	else if (ft_strcmp(data->command->args[0], "exit") == 0)
		ft_exit(data);
}

int	is_builtin(t_data *data)
{
	char	*cmd;

	if (!data->command->args[0])
		return (0);
	cmd = data->command->args[0];
	return (ft_strcmp(cmd, "echo") == 0 || ft_strcmp(cmd, "cd") == 0
		|| ft_strcmp(cmd, "pwd") == 0 || ft_strcmp(cmd, "export") == 0
		|| ft_strcmp(cmd, "unset") == 0 || ft_strcmp(cmd, "env") == 0
		|| ft_strcmp(cmd, "exit") == 0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_path.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/22 19:03:09 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:17 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_strjoin_with_slash(const char *s1, const char *s2)
{
	char	*tmp;
	char	*result;

	tmp = ft_strjoin(s1, "/");
	if (!tmp)
		return (NULL);
	result = ft_strjoin(tmp, s2);
	free(tmp);
	return (result);
}

char	*find_command_path(char *cmd, t_data *data)
{
	char	**path_dirs;
	char	*path_env;
	char	*full_path;
	int		i;

	if (access(cmd, X_OK) == 0)
		return (ft_strdup(cmd));
	path_env = find_path(data);
	path_dirs = ft_split(path_env, ':');
	i = 0;
	while (path_dirs[i])
	{
		full_path = ft_strjoin_with_slash(path_dirs[i], cmd);
		if (access(full_path, X_OK) == 0)
			return (full_path);
		i++;
	}
	i = 0;
	return (NULL);
}

char	*find_path(t_data *data)
{
	char	*path;
	int		i;

	i = 0;
	while (data->env[i])
	{
		if (ft_strncmp(data->env[i], "PATH=", 5) == 0)
		{
			path = ft_strdup(data->env[i]);
			break ;
		}
		i++;
	}
	return (path);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/05 18:56:58 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:16 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	process_command_line(t_data *data)
{
	g_signals(1);
	data->pid_index = 0;
	data->pids = malloc(sizeof(pid_t) * (data->token_count + 1));
	init_pid_list(data);
	while (data->current_token < data->token_count)
	{
		if (parse_command(data) != 0)
		{
			while (data->current_token < data->token_count
				&& data->tokens[data->current_token].type != TOKEN_PIPE)
				data->current_token++;
			if (data->current_token < data->token_count
				&& data->tokens[data->current_token].type == TOKEN_PIPE)
				data->current_token++;
			continue ;
		}
		if (execute_command(data) != 0)
			return (1);
		if (data->current_token < data->token_count
			&& data->tokens[data->current_token].type == TOKEN_PIPE)
			data->current_token++;
	}
	wait_for_children(data);
	g_signals(0);
	return (0);
}

void	start_fork(t_data *data, char *cmd_path, int is_builtin_cmd)
{
	data->pid = fork();
	data->pids[data->pid_index++] = data->pid;
	if (data->pid == 0)
		run_child_process(data, cmd_path, is_builtin_cmd);
	else
		cleanup_parent(data);
}

int	execute_command(t_data *data)
{
	char	*cmd_path;
	int		is_builtin_cmd;

	prepare_pipe_connection(data);
	is_builtin_cmd = is_builtin(data);
	if (is_builtin_cmd && data->command->input_fd == STDIN_FILENO
		&& data->command->output_fd == STDOUT_FILENO
		&& data->command->fd_out == -1 && data->prev_pipe_read_end == -1)
	{
		exec_builtins(data);
		return (0);
	}
	cmd_path = NULL;
	if (is_builtin_cmd == 0)
	{
		cmd_path = find_command_path(data->command->args[0], data);
		if (!cmd_path)
		{
			ft_putstr_fd(data->command->args[0], 2);
			ft_putstr_fd(": command not found\n", 2);
			return (1);
		}
	}
	start_fork(data, cmd_path, is_builtin_cmd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/29 17:51:27 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:17 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	wait_for_children(t_data *data)
{
	int	i;
	int	status;

	i = 0;
	while (data->pids[i] != -1)
		waitpid(data->pids[i++], &status, 0);
}

void	run_child_process(t_data *data, char *cmd_path, int is_builtin_cmd)
{
	if (data->command->input_fd != STDIN_FILENO)
		dup2(data->command->input_fd, STDIN_FILENO);
	if (data->command->output_fd != STDOUT_FILENO)
		dup2(data->command->output_fd, STDOUT_FILENO);
	else if (data->command->fd_out != -1)
		dup2(data->command->fd_out, STDOUT_FILENO);
	if (data->prev_pipe_read_end != -1)
		close(data->prev_pipe_read_end);
	if (is_builtin_cmd)
		exec_builtins(data);
	else
		execve(cmd_path, data->command->args, data->env);
	exit(1);
}

void	cleanup_parent(t_data *data)
{
	if (data->command->fd_out != -1)
		close(data->command->fd_out);
	if (data->command->input_fd != STDIN_FILENO)
		close(data->command->input_fd);
	if (data->command->output_fd != STDOUT_FILENO)
		close(data->command->output_fd);
	if (data->command->error_pipe_write != -1)
		close(data->command->error_pipe_write);
}

void	setup_pipe(t_data *data, int pipe_fd[2])
{
	int	error_pipe[2];

	if (pipe(pipe_fd) == -1)
	{
		perror("pipe");
		exit(1);
	}
	if (pipe(error_pipe) == -1)
	{
		perror("pipe");
		exit(1);
	}
	data->prev_pipe_read_end = pipe_fd[0];
	data->command->fd_out = pipe_fd[1];
	data->command->error_pipe_read = error_pipe[0];
	data->command->error_pipe_write = error_pipe[1];
}

void	prepare_pipe_connection(t_data *data)
{
	int	pipe_fd[2];

	if (data->current_token < data->token_count
		&& data->tokens[data->current_token].type == TOKEN_PIPE
		&& data->command->output_fd == STDOUT_FILENO)
		setup_pipe(data, pipe_fd);
	else
		data->command->fd_out = -1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 14:33:24 by rabatist          #+#    #+#             */
/*   Updated: 2025/02/15 00:16:39 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*dollar_question(t_data *data, int *i, char *result)
{
	char	*exit_str;
	char	*tmp;

	exit_str = ft_itoa(data->exit_status);
	tmp = ft_strjoin(result, exit_str);
	free(result);
	result = tmp;
	free(exit_str);
	(*i) += 2;
	return (result);
}

char	*only_dollar(int *i, char *str, char *result)
{
	char	buf[2];
	char	*tmp;

	buf[0] = str[(*i)];
	buf[1] = '\0';
	tmp = ft_strjoin(result, buf);
	free(result);
	result = tmp;
	(*i)++;
	return (result);
}

char	*expand_dollar(t_data *data, int *i, char *str, char *result)
{
	char	*tmp;
	char	*env_val;
	char	*var;
	int		j;

	(*i)++;
	j = (*i);
	while (str[j] && (ft_isalnum(str[j]) || str[j] == '_'))
		j++;
	var = ft_substr(str, (*i), j - (*i));
	env_val = get_env_value(var, data);
	if (!env_val)
		env_val = ft_strdup("");
	tmp = ft_strjoin(result, env_val);
	free(result);
	result = tmp;
	free(var);
	free(env_val);
	(*i) = j;
	return (result);
}

char	*no_dollar(int *i, char *str, char *result)
{
	char	buf[2];
	char	*tmp;

	buf[0] = str[(*i)];
	buf[1] = '\0';
	tmp = ft_strjoin(result, buf);
	free(result);
	result = tmp;
	(*i)++;
	return (result);
}

char	*manage_dollar(char *str, t_data *data)
{
	char	*result;
	int		i;

	i = 0;
	result = ft_strdup("");
	while (str[i])
	{
		if (str[i] == '$' && str[i + 1] == '?')
			result = dollar_question(data, &i, result);
		else if (str[i] == '$' && (ft_isspace(str[i + 1]) == 1
				|| str[i + 1] == '\0'))
			result = only_dollar(&i, str, result);
		else if (str[i] == '$')
			result = expand_dollar(data, &i, str, result);
		else
			result = no_dollar(&i, str, result);
	}
	return (result);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 21:29:23 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 23:49:13 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_env_value(char *str, t_data *data)
{
	int		i;
	char	*value;

	i = 0;
	while (data->env[i])
	{
		if (ft_strncmp(data->env[i], str, ft_strlen(str)) == 0
			&& data->env[i][ft_strlen(str)] == '=')
		{
			value = ft_strdup(data->env[i] + ft_strlen(str) + 1);
			return (value);
		}
		i++;
	}
	return (NULL);
}

void	get_exit_status(t_data *data, int i)
{
	char	*exit_status;

	exit_status = ft_itoa(data->exit_status);
	free(data->command->args[i]);
	data->command->args[i] = exit_status;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/04 16:06:44 by rabatist          #+#    #+#             */
/*   Updated: 2025/02/14 22:24:14 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_all_exit(int exit_code)
{
	printf("exit\n");
	exit(exit_code);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/15 14:10:21 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:13 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	init_data(t_data *data, char **env)
{
	data->env = env;
	data->tokens = NULL;
	data->token_count = 0;
	data->current_token = 0;
	data->command = NULL;
	data->input = NULL;
	data->pids = NULL;
	data->pid_index = 0;
	data->exit_status = 0;
	data->flag_error = 0;
	data->start = 0;
}

void	init_command(t_data *data)
{
	data->command = malloc(sizeof(t_command));
	data->command->args = malloc(sizeof(char *) * (data->token_count + 1));
	data->command->fd_out = -1;
	data->command->fd_in = -1;
	data->command->error_pipe_read = -1;
	data->command->error_pipe_write = -1;
	data->command->args_count = 0;
	data->command->input_fd = STDIN_FILENO;
	data->command->output_fd = STDOUT_FILENO;
	data->command->args[0] = NULL;
}

void	init_pid_list(t_data *data)
{
	int	i;

	i = 0;
	while (i <= data->token_count)
		data->pids[i++] = -1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/05 18:56:15 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:11 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	start(t_data *data)
{
	while (1)
	{
		data->input = readline("minishell> ");
		if (!data->input)
		{
			printf("exit\n");
			break ;
		}
		add_history(data->input);
		parsing(data);
		data->current_token = 0;
		process_command_line(data);
	}
}

int	main(int ac, char **av, char **env)
{
	t_data	data;

	(void)ac;
	(void)av;
	init_data(&data, env);
	make_env(&data, env);
	make_exp(&data, env);
	signals();
	start(&data);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   make_env.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/30 16:11:24 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:11 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	make_env(t_data *data, char **env)
{
	int	i;
	int	j;

	i = 0;
	while (env[i])
		i++;
	data->env = malloc(sizeof(char *) * (i + 1));
	if (!data->env)
		exit(1);
	j = -1;
	while (++j < i)
		data->env[j] = ft_strdup(env[j]);
	data->env[i] = NULL;
}

void	make_exp(t_data *data, char **env)
{
	int	i;

	i = 0;
	while (env[i])
		i++;
	data->exp = malloc(sizeof(char *) * (i + 1));
	if (!data->exp)
		exit(1);
	i = 0;
	while (env[i])
	{
		data->exp[i] = ft_strdup(env[i]);
		if (!data->exp[i])
		{
			while (--i >= 0)
				free(data->exp[i]);
			free(data->exp);
			exit(1);
		}
		i++;
	}
	data->exp[i] = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/05 16:24:57 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:08 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	add_token(t_data *data, char *start, int len, int type)
{
	t_token	new_token;
	t_token	*new_tokens;
	int		i;

	new_token.value = ft_strndup(start, len);
	new_token.type = type;
	new_tokens = malloc(sizeof(t_token) * (data->token_count + 1));
	i = -1;
	while (++i < data->token_count)
		new_tokens[i] = data->tokens[i];
	new_tokens[data->token_count] = new_token;
	data->token_count++;
	free(data->tokens);
	data->tokens = new_tokens;
}

void	handle_operator(t_data *data, int *i)
{
	int	op_len;
	int	type;

	op_len = 1;
	type = TOKEN_WORD;
	if ((data->input[*i] == '>' && data->input[*i + 1] == '>')
		|| (data->input[*i] == '<' && data->input[*i + 1] == '<'))
	{
		op_len = 2;
		if (data->input[*i] == '>')
			type = TOKEN_REDIRECT_APPEND;
		else
			type = TOKEN_HEREDOC;
	}
	else if (data->input[*i] == '>')
		type = TOKEN_REDIRECT_OUT;
	else if (data->input[*i] == '<')
		type = TOKEN_REDIRECT_IN;
	else if (data->input[*i] == '|')
		type = TOKEN_PIPE;
	add_token(data, &data->input[*i], op_len, type);
	*i += op_len;
}

void	find_end_of_word(t_data *data, int *i)
{
	char	quote_type;

	while (data->input[*i] && data->input[*i] != ' ' && data->input[*i] != '|'
		&& data->input[*i] != '<' && data->input[*i] != '>')
	{
		if (data->input[*i] == '\'' || data->input[*i] == '"')
		{
			quote_type = data->input[*i];
			(*i)++;
			while (data->input[*i] && data->input[*i] != quote_type)
				(*i)++;
			if (data->input[*i] != quote_type)
			{
				ft_putstr_fd("minishell: unclosed quote\n", 2);
				data->exit_status = 1;
				return ;
			}
			(*i)++;
		}
		else
			(*i)++;
	}
}

void	parse_word(t_data *data, int *i)
{
	t_token	token;
	char	*tmp;
	char	*new_tmp;
	int		start;
	int		j;

	start = *i;
	find_end_of_word(data, i);
	data->content = ft_substr(data->input, start, *i - start);
	token.value = data->content;
	token.type = TOKEN_WORD;
	token.sub_tokens = NULL;
	analyse_quotes(&token, data);
	tmp = ft_strdup("");
	j = 0;
	while (token.sub_tokens && token.sub_tokens[j])
	{
		new_tmp = ft_strjoin(tmp, token.sub_tokens[j]->content);
		tmp = new_tmp;
		j++;
	}
	token.value = tmp;
	add_token(data, token.value, ft_strlen(token.value), TOKEN_WORD);
}

void	parsing(t_data *data)
{
	int	i;

	i = 0;
	data->tokens = NULL;
	data->token_count = 0;
	while (data->input[i])
	{
		while (ft_isspace(data->input[i]))
			i++;
		if (!data->input[i])
			break ;
		else if (data->input[i] == '|' || data->input[i] == '<'
			|| data->input[i] == '>')
			handle_operator(data, &i);
		else
			parse_word(data, &i);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_command.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 22:14:53 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:09 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_previous_pipe(t_data *data)
{
	if (data->prev_pipe_read_end == -1)
		return ;
	if (data->command->input_fd == STDIN_FILENO)
	{
		data->command->input_fd = data->prev_pipe_read_end;
		data->prev_pipe_read_end = -1;
	}
	else
	{
		close(data->prev_pipe_read_end);
		data->prev_pipe_read_end = -1;
	}
}

int	manage_redirect_processed(t_data *data)
{
	int	redirect_processed;

	while (data->current_token < data->token_count)
	{
		if (data->tokens[data->current_token].type == TOKEN_PIPE)
			break ;
		redirect_processed = handle_redirection(data);
		if (redirect_processed == -1)
			return (1);
		if (redirect_processed > 0)
		{
			if ((data->command->input_fd == -1)
				|| (data->command->output_fd == -1))
				return (1);
		}
		else if (redirect_processed == 0)
		{
			data->command->args[data->command->args_count]
				= data->tokens[data->current_token].value;
			data->command->args_count++;
			data->current_token++;
		}
	}
	return (0);
}

int	parse_command(t_data *data)
{
	int	return_value;

	init_command(data);
	handle_previous_pipe(data);
	return_value = manage_redirect_processed(data);
	if (return_value == 1)
		return (1);
	data->command->args[data->command->args_count] = NULL;
	if (data->command->args_count == 0)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing_sub_token.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 20:22:09 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 23:57:36 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	find_words(t_data *data, int *i)
{
	int		sub_token_count;
	char	quote_type;

	while (data->content[*(i)])
	{
		if (data->content[*(i)] == '\'' || data->content[*(i)] == '"')
		{
			quote_type = data->content[(*i)++];
			while (data->content[(*i)] && data->content[(*i)] != quote_type)
				(*i)++;
			if (data->content[(*i)] == quote_type)
				(*i)++;
			sub_token_count++;
		}
		else
			while (data->content[(*i)] && data->content[(*i)] != '\''
				&& data->content[(*i)] != '"' && data->content[(*i)] != ' '
				&& data->content[(*i)] != '|' && data->content[(*i)] != '<'
				&& data->content[(*i)] != '>')
				(*i)++;
		sub_token_count++;
	}
	return (sub_token_count);
}

int	number_of_sub_token(t_data *data, int i)
{
	int	sub_token_count;

	sub_token_count = 0;
	sub_token_count = find_words(data, &i);
	return (sub_token_count);
}

void	sub_token_quotes(t_token *token, t_data *data, int *i,
		int *sub_token_count)
{
	int		start;
	char	quote_type;

	quote_type = data->content[(*i)++];
	start = *i;
	while (data->content[*i] && data->content[*i] != quote_type)
		(*i)++;
	token->sub_tokens[*sub_token_count] = malloc(sizeof(t_sub_token));
	if (!token->sub_tokens[*sub_token_count])
		return ;
	if (quote_type == '\'')
		token->sub_tokens[*sub_token_count]->type = TOKEN_SQUOTE;
	else if (quote_type == '"')
		token->sub_tokens[*sub_token_count]->type = TOKEN_DQUOTE;
	token->sub_tokens[*sub_token_count]->content = ft_substr(data->content,
			start, *i - start);
	if (quote_type == '"')
	{
		token->sub_tokens[*sub_token_count]->content
			= manage_dollar(token->sub_tokens[*sub_token_count]->content,
				data);
	}
	(*sub_token_count)++;
	if (data->content[*i] == quote_type)
		(*i)++;
}

void	sub_token_word(t_token *token, t_data *data, int *i,
		int *sub_token_count)
{
	int	start;

	start = *i;
	while (data->content[*i] && data->content[*i] != '\''
		&& data->content[*i] != '"' && data->content[*i] != ' '
		&& data->content[*i] != '|' && data->content[*i] != '<'
		&& data->content[*i] != '>')
		(*i)++;
	if (*i > start)
	{
		token->sub_tokens[*sub_token_count] = malloc(sizeof(t_sub_token));
		if (!token->sub_tokens[*sub_token_count])
			return ;
		token->sub_tokens[*sub_token_count]->type = TOKEN_NO_QUOTE;
		token->sub_tokens[*sub_token_count]->content = ft_substr(data->content,
				start, *i - start);
		token->sub_tokens[*sub_token_count]->content
			= manage_dollar(token->sub_tokens[*sub_token_count]->content,
				data);
		(*sub_token_count)++;
	}
}

void	analyse_quotes(t_token *token, t_data *data)
{
	int	sub_token_count;
	int	i;

	i = 0;
	sub_token_count = number_of_sub_token(data, i);
	token->sub_tokens = malloc(sizeof(t_sub_token *) * (sub_token_count + 1));
	if (!token->sub_tokens)
		return ;
	token->sub_tokens[sub_token_count] = NULL;
	sub_token_count = 0;
	while (data->content[i])
	{
		if (data->content[i] == '\'' || data->content[i] == '"')
			sub_token_quotes(token, data, &i, &sub_token_count);
		else
			sub_token_word(token, data, &i, &sub_token_count);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/22 19:04:22 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:07 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	redirect_in(t_data *data, int token_count)
{
	char	*filename;

	if (data->tokens[data->current_token].type == TOKEN_REDIRECT_IN)
	{
		if (data->current_token + 1 >= token_count)
		{
			ft_putstr_fd(ERROR, 2);
			return (-1);
		}
		filename = data->tokens[data->current_token + 1].value;
		data->command->input_fd = open(filename, O_RDONLY);
		if (data->command->input_fd == -1)
		{
			perror("minishell");
			return (-1);
		}
		return (2);
	}
	return (0);
}

int	redirect_out(t_data *data, int token_count)
{
	char	*filename;

	if (data->tokens[data->current_token].type == TOKEN_REDIRECT_OUT)
	{
		if (data->current_token + 1 >= token_count)
		{
			ft_putstr_fd(ERROR, 2);
			return (-1);
		}
		filename = data->tokens[data->current_token + 1].value;
		data->command->output_fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC,
				0644);
		if (data->command->output_fd == -1)
		{
			perror("minishell");
			return (-1);
		}
		return (2);
	}
	return (0);
}

int	redirect_append(t_data *data, int token_count)
{
	char	*filename;

	if (data->tokens[data->current_token].type == TOKEN_REDIRECT_APPEND)
	{
		if (data->current_token + 1 >= token_count)
		{
			ft_putstr_fd(ERROR, 2);
			return (-1);
		}
		filename = data->tokens[data->current_token + 1].value;
		data->command->output_fd = open(filename, O_WRONLY | O_CREAT | O_APPEND,
				0644);
		if (data->command->output_fd == -1)
		{
			perror("minishell");
			return (-1);
		}
		return (2);
	}
	return (0);
}

int	redirect_heredoc(t_data *data, int token_count)
{
	char	*delimiter;
	int		pipe_fd[2];
	char	*line;

	if (data->tokens[data->current_token].type != TOKEN_HEREDOC)
		return (0);
	if (data->current_token + 1 >= token_count)
	{
		ft_putstr_fd(ERROR, 2);
		return (-1);
	}
	delimiter = data->tokens[data->current_token + 1].value;
	pipe(pipe_fd);
	while (1)
	{
		line = readline("> ");
		if (ft_strcmp(line, delimiter) == 0)
			break ;
		write(pipe_fd[1], line, ft_strlen(line));
		write(pipe_fd[1], "\n", 1);
	}
	close(pipe_fd[1]);
	data->command->input_fd = pipe_fd[0];
	return (2);
}

int	handle_redirection(t_data *data)
{
	int	processed;

	processed = redirect_in(data, data->token_count);
	if (processed != 0)
		return (process_redirection(processed, data));
	processed = redirect_out(data, data->token_count);
	if (processed != 0)
		return (process_redirection(processed, data));
	processed = redirect_append(data, data->token_count);
	if (processed != 0)
		return (process_redirection(processed, data));
	processed = redirect_heredoc(data, data->token_count);
	if (processed != 0)
		return (process_redirection(processed, data));
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirect_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/03 17:22:40 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:08 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	process_redirection(int processed, t_data *data)
{
	if (processed == -1)
		return (-1);
	data->current_token += processed;
	return (processed);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/31 14:29:47 by rabatist          #+#    #+#             */
/*   Updated: 2025/02/15 00:17:22 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	g_signals(int new)
{
	static int	value;

	if (new == -1)
		return (value);
	value = new;
	return (value);
}

void	sig_int(int signal)
{
	(void)signal;
	printf("\n");
	rl_replace_line("", 0);
	rl_on_new_line();
	if (!g_signals(-1))
		rl_redisplay();
}

void	signals(void)
{
	signal(SIGINT, &sig_int);
	signal(SIGQUIT, SIG_IGN);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nbonnet <nbonnet@student.42lausanne.ch>    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/01/14 15:21:23 by nbonnet           #+#    #+#             */
/*   Updated: 2025/02/14 22:24:05 by nbonnet          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	ft_strcpy(char *dst, char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dst[i] = src[i];
		i++;
	}
	dst[i] = '\0';
}

int	ft_strcmp(char *s1, char *s2)
{
	int	i;

	i = 0;
	while (s1[i] != '\0' && s2[i] != '\0' && s1[i] == s2[i])
		i++;
	return (((unsigned char *)s1)[i] - ((unsigned char *)s2)[i]);
}

int	ft_strnlen(const char *s, int maxlen)
{
	int	len;

	len = 0;
	while (len < maxlen && s[len])
		len++;
	return (len);
}

char	*ft_strndup(const char *s, int n)
{
	int		len;
	char	*dup;

	len = ft_strnlen(s, n);
	dup = malloc(sizeof(char) * (len + 1));
	if (!dup)
		return (NULL);
	ft_strlcpy(dup, s, len + 1);
	dup[len] = '\0';
	return (dup);
}

int	ft_isspace(char c)
{
	if (c == ' ' || c == '\t' || c == '\n' || c == '\v' || c == '\f'
		|| c == '\r')
		return (1);
	return (0);
}
